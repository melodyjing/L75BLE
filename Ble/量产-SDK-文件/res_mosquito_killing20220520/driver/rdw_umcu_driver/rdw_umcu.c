//liujian add
//2018/7/17
//umcu control
#include "rdw_umcu.h"
#include "rdw_mcu.h"
#include "pmu.h"
#include "stdint.h"
#include "stdbool.h"
#include "reg_access.h"
#include <string.h>
#include "irda.h"

#if CFG_USE_RDW_UMCU	

void umcu_interrupt_select(void);

#define UMCU_IRAM_RST_N			0x0001
#define UMCU_IRAM_ENABLE			0x0002
#define UMCU_IRAM_OWNER_P0U1		0x0004
#define UMCU_IRAM_CLK_SVEN		0x0008

//#define PROGRAM_LENGTH  12
uint16_t  umcu_program[] = {

0x6c02,
0x4000,
0x004c,
0x0a0c,
0xb010,
0xc000,
0x008c,
0x080c,
0x440a,
0x4008,
0x004c,
0x801f,
0xc000,
0x0086,
0x0406,
0x004c,
0x81ff,
0xc000,
0x008a,
0x00ca,
0x4c16,
0x4013,
0x0049,
0x0086,
0x0406,
0x004c,
0x8032,
0xc000,
0x008a,
0x00ca,
0x6262,
0x6468,
0x666e,
0x6875,
0x6a7c,
0x4c25,
0x401d,
0x0049,
0x0086,
0x0106,
0x0406,
0x004c,
0x8032,
0xc000,
0x008a,
0x00ca,
0x6482,
0x6689,
0x6890,
0x6a96,
0x4c34,
0x402d,
0x0049,
0x0086,
0x0106,
0x0106,
0x0406,
0x004c,
0x8032,
0xc000,
0x008a,
0x00ca,
0x669d,
0x68a4,
0x6aac,
0x4c43,
0x403d,
0x0049,
0x0086,
0x0106,
0x0106,
0x0106,
0x0406,
0x004c,
0x8032,
0xc000,
0x008a,
0x00ca,
0x68b4,
0x6abb,
0x4c52,
0x404d,
0x0049,
0x0086,
0x0106,
0x0106,
0x0106,
0x0106,
0x0406,
0x004c,
0x8032,
0xc000,
0x008a,
0x00ca,
0x6ac3,
0x4c61,
0x405d,
0x4000,
0x004a,
0x008c,
0x0c0c,
0x000c,
0x140c,
0x40cb,
0x0046,
0x008c,
0x0c0c,
0x000c,
0x140c,
0x40cb,
0x004a,
0x0086,
0x008c,
0x0c0c,
0x000c,
0x140c,
0x40cb,
0x0046,
0x0086,
0x008c,
0x0c0c,
0x000c,
0x140c,
0x40cb,
0x004b,
0x008c,
0x0c0c,
0x000c,
0x140c,
0x40cb,
0x004b,
0x008a,
0x008c,
0x0c0c,
0x000c,
0x140c,
0x40cb,
0x004b,
0x0086,
0x008c,
0x0c0c,
0x000c,
0x140c,
0x40cb,
0x0048,
0x008c,
0x0c0c,
0x000c,
0x140c,
0x40cb,
0x0048,
0x008a,
0x008c,
0x0c0c,
0x000c,
0x140c,
0x40cb,
0x0048,
0x0086,
0x008c,
0x0c0c,
0x000c,
0x140c,
0x40cb,
0x0048,
0x0086,
0x008a,
0x008c,
0x0c0c,
0x000c,
0x140c,
0x40cb,
0x0048,
0x0086,
0x0086,
0x008c,
0x0c0c,
0x000c,
0x140c,
0x40cb,
0x0048,
0x008b,
0x008c,
0x0c0c,
0x000c,
0x140c,
0x40cb,
0x0048,
0x008b,
0x008a,
0x008c,
0x0c0c,
0x000c,
0x140c,
0x40cb,
0x0048,
0x008b,
0x0086,
0x008c,
0x0c0c,
0x000c,
0x140c,
0x40cb,
0x44cd,
0x40cb,
0x004c,
0xb000,
0xc000,
0x008c,
0x080c,
0x44d4,
0x40d2,
0x004c,
0x800b,
0xc000,
0x008c,
0x140c,
0x44db,
0x40d9,
0x004a,
0x008a,
0x0a0c,
0x4000,


};

void copy_umcu_program(uint16_t * p_program )
{
		uint16_t i;
		volatile uint32_t * p_temp;
		p_temp = (volatile uint32_t *)(UMCU_PROGRAM_ADDRESS);
	  for(i = 0; i < sizeof(umcu_program)/sizeof(uint16_t); i++)
		{
				*p_temp++ = umcu_program[i];
		}
}

void rdw_umcu_init(void)
{
	  volatile RDW_IRDA_T   *  p_temp;
	
	  p_temp = RDW_IRDA;
     	
	volatile uint32_t * p_ctrl; // = (volatile uint32_t *)(RDW_UMCU_IRAM_CTRL);
	  
	  p_ctrl = (volatile uint32_t *)(RDW_UMCU_IRAM_INT);
	  *p_ctrl = 0x03;
	
	  umcu_interrupt_select();
	
	 
	  
	  p_temp->TX_CONFIG = p_temp->TX_CONFIG | (1<<6);
		copy_umcu_program(umcu_program);
	  p_ctrl  = (volatile uint32_t *)(RDW_UMCU_IRAM_CTRL);
	  *p_ctrl =  *p_ctrl|UMCU_IRAM_RST_N;
		*p_ctrl =  *p_ctrl&~UMCU_IRAM_RST_N;
	   
	   p_ctrl = (volatile uint32_t *) (RDW_UMCU_PAD_CTRL);
    *p_ctrl = 0x55555555;	
		
	  p_ctrl = (volatile uint32_t *)(RDW_UMCU_IRAM_CTRL);
		*p_ctrl =  *p_ctrl|UMCU_IRAM_ENABLE|UMCU_IRAM_OWNER_P0U1;
	//  IntEnable(UMCU_INT);
		
		NVIC_EnableIRQ(AON_EVENT3_IRQn);
}

void umcu_interrupt_select(void)
{
	REG_PL_WR(PMU_BASE+AON_CONFIG_PROTECT,1);
	
	REG_PL_WR(PMU_BASE+AON_IO_EDGE_CTRL,(REG_PL_RD(PMU_BASE+AON_IO_EDGE_CTRL))|0x01);	
	
	REG_PL_WR(PMU_BASE+0x188,(REG_PL_RD(PMU_BASE+0x188))&(~(0x1f<<16)));	
	REG_PL_WR(PMU_BASE+0x188,(REG_PL_RD(PMU_BASE+0x188))|(7<<16));	
	
	
	REG_PL_WR(PMU_BASE+AON_CONFIG_PROTECT,0);
}


void uMCU_INTERRUPT(void)
{
		uint32_t key;
		volatile uint32_t * p_ctrl = (volatile uint32_t *)(RDW_UMCU_IRAM_KEY);
	  key = *p_ctrl;
	  printf("key = %d \n", key-1);
	
		p_ctrl = (volatile uint32_t *)(RDW_UMCU_IRAM_INT);
	  *p_ctrl = 0x03;
	  
	  p_ctrl = (volatile uint32_t *)(RDW_UMCU_IRAM_CTRL);
	//  *p_ctrl = *p_ctrl & (~UMCU_IRAM_ENABLE);
	
	  *p_ctrl = 0x0f;
		
}


#endif


















